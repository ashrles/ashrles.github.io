<!DOCTYPE html>
<!-- saved from url=(0059)http://anoopsarkar.github.io/compilers-class/decafspec.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="http://anoopsarkar.github.io/compilers-class/favicon.ico">
    <title>SFU Compilers class: Decaf Specification</title>

    <!-- CSS -->
    <link href="./SFUCompilersclass_DecafSpecification_files/bootstrap.min.css" rel="stylesheet">
    <link href="./SFUCompilersclass_DecafSpecification_files/bootstrap-glyphicons.css" rel="stylesheet">
    <link href="./SFUCompilersclass_DecafSpecification_files/compilers-class.css" rel="stylesheet">   
    <link href="./SFUCompilersclass_DecafSpecification_files/font-awesome.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="./SFUCompilersclass_DecafSpecification_files/jquery.min.js"></script>

    <!-- MathJax -->
    <script type="text/javascript" src="./SFUCompilersclass_DecafSpecification_files/MathJax.js">
    </script>
  <style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
  <body><div id="MathJax_Message" style="display: none;"></div>
    <a class="sr-only" href="http://anoopsarkar.github.io/compilers-class/decafspec.html#content">Skip to main content</a>

    <!-- Docs master nav -->
    <header class="navbar navbar-fixed-top navbar-default" role="banner">
      <div class="container">
        <div class="row">
        <div class="navbar-header">
          <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <ul class="nav navbar-nav">
            <li id="main_page"><a href="http://anoopsarkar.github.io/compilers-class/index.html" class="navbar-brand">Compilers</a></li>
          </ul>
        </div>
        <nav class="collapse navbar-collapse" role="navigation">
          <ul class="nav navbar-nav">
            <li id="syllabus"><a href="http://anoopsarkar.github.io/compilers-class/syllabus.html">Syllabus</a></li>
            <li id="practice">
              <a class="dropdown-toggle" data-toggle="dropdown" href="http://anoopsarkar.github.io/compilers-class/decafspec.html#">Practice <span class="caret"></span></a>
              <ol class="dropdown-menu">
                <li><a href="http://anoopsarkar.github.io/compilers-class/lex-practice.html">Lex Practice</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/yacc-practice.html">Yacc Practice</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/llvm-practice.html">LLVM Practice</a></li>
              </ol>
            </li>
            <li id="homework" class="active">
              <a class="dropdown-toggle" data-toggle="dropdown" href="http://anoopsarkar.github.io/compilers-class/decafspec.html#">Homework <span class="caret"></span></a>
              <ol class="dropdown-menu">
                <li><a href="http://anoopsarkar.github.io/compilers-class/hw0.html">0. Setup</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/hw1.html">1. Lexical Analysis</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/hw2.html">2. Parsing</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/hw3.html">3. Expr Codegen</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/hw4.html">4. Decaf Compiler</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/decafspec.html">Decaf specification</a></li>
                <li><a href="http://anoopsarkar.github.io/compilers-class/hwcontest.html">Compiler Contest</a></li>
              </ol>
            </li>
            <li id="leaderboard"><a href="http://anoopsarkar.github.io/compilers-class/leaderboard.html">Leaderboard</a></li>
            <li id="textbook"><a href="http://anoopsarkar.github.io/compilers-class/textbook.html">Textbook</a></li>
            <li id="faq"><a href="http://anoopsarkar.github.io/compilers-class/faq.html">FAQ</a></li>
          </ul>
        </nav>
      </div>
      </div>
    </header>

    <div class="container">
      <div class="row">
        <div class="col-sm-2 hidden-sm hidden-xs">
          <a href="http://inthelandofinventedlanguages.com/"> 
          <img src="./SFUCompilersclass_DecafSpecification_files/okrentbook.jpg" class="img-responsive img-rounded" alt="">
          </a> 
          <span class="text-muted"><i><p><strong>In the Land of Invented Languages</strong> is a book by Anita Okrent about some of the nearly nine hundred languages invented for human communication.</p>
</i></span>
        </div>
        <div class="col-sm-10">
          <h2 id="decaf-programming-language-specification-span-classtext-mutedsummer-2016span">Decaf Programming Language Specification <span class="text-muted">Summer 2016</span></h2>

<h2 id="introduction">Introduction</h2>
<p>Note: This page has been archived. The original is constantly changing and may not exist at this moment in time.</p>
<p>This is the reference manual for the Decaf programming language which is the programming language specifically for the <a href="http://anoopsarkar.github.io/compilers-class">CMPT 379: Compilers</a> course taught by <a href="http://www.cs.sfu.ca/~anoop/">Anoop Sarkar</a> at the SFU Computing Science School (Burnaby campus). For more information and other documentation, see the course web page.</p>

<p>Decaf is a strongly typed C-like language. The feature set is trimmed down considerably from what is usually part of a full-fledged programming language. This is done to keep the programming assignments manageable. Despite these limitations, Decaf will be able to handle interesting and non-trivial programs.</p>

<p>Here is an example Decaf program:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>extern func print_int(int) void;

package GreatestCommonDivisor {
    var a int = 10;
    var b int = 20;

    func main() int {
        var x, y, z int;
        x = a;
        y = b;
        z = gcd(x, y);

        // print_int is part of the standard input-output library
        print_int(z);
    }

    // function that computes the greatest common divisor
    func gcd(a int, b int) int {
        if (b == 0) { return(a); }
        else { return( gcd(b, a % b) ); }
    }
}
</code></pre>
</div>

<h2 id="notation">Notation</h2>

<p>The syntax is specified using <a href="http://en.wikipedia.org/wiki/Extended_Backus-Naur_Form">Extended Backus-Naur Form</a> (EBNF):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "..." token ] | Group | Option | Repetition | Repetition+ | CommaList .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
Repetition+ = "{" Expression "}+" .
CommaList   = "{" Expression "}+," .
</code></pre>
</div>

<p>Productions are expressions constructed from terms and the following operators, in increasing precedence:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>|    alternation
()   grouping
[]   option (0 or 1 Expression)
{}   repetition (0 to n Expressions)
{}+  repetition (1 to n Expressions)
{}+, comma list (1 to n Expressions comma separated, e.g. x, y, z)
</code></pre>
</div>

<p>Lower-case production names are used to identify lexical tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes “” or back quotes ``.</p>

<p>The form <code class="highlighter-rouge">a ... b</code> represents the set of characters from a through b as alternatives. The horizontal ellipsis <code class="highlighter-rouge">...</code> is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character <code class="highlighter-rouge">...</code> is not a token of the Decaf language.</p>

<h2 id="source-code-representation">Source code representation</h2>

<p>Decaf source code is encoded as ASCII text. Upper and lower case characters are considered different characters. For example, <code class="highlighter-rouge">if</code> is defined as a keyword, but <code class="highlighter-rouge">IF</code> would be considered an identifier.</p>

<h3 id="ascii-table">ASCII table</h3>

<p>The ASCII table and decimal equivalent for each character is shown below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel
  8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si
 16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb
 24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us
 32 sp    33  !    34  "    35  #    36  $    37  %    38  &amp;    39  '
 40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /
 48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7
 56  8    57  9    58  :    59  ;    60  &lt;    61  =    62  &gt;    63  ?
 64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G
 72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O
 80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W
 88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _
 96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g
104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o
112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w
120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del
</code></pre>
</div>

<p>The set of valid characters in Decaf is all the ASCII characters:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>all_char = /* all ASCII characters from 7 ... 13 and 32 ... 126 */ .
char = /* all ASCII characters from 7 ... 13 and 32 ... 126 except char 92 "\" */ .
char_no_nl = /* all ASCII characters from 7 ... 13 and 32 ... 126 except char 10 "\n" */ .
</code></pre>
</div>

<p>Implementation restriction: For compatibility with other tools, a compiler should always disallow the <code class="highlighter-rouge">nul</code> character (decimal: 0) in the source text.</p>

<h3 id="letters-and-digits">Letters and Digits</h3>

<p>The underscore character <code class="highlighter-rouge">_</code> is considered a letter.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>letter        = "A" ... "Z" | "a" ... "z" | "_" .
decimal_digit = "0" ... "9" .
hex_digit     = "0" ... "9" | "A" ... "F" | "a" ... "f" .
digit         = "0" ... "9" .
</code></pre>
</div>

<h2 id="lexical-elements">Lexical Elements</h2>

<h3 id="comments">Comments</h3>

<p>Decaf only has line comments that start with the character sequence <code class="highlighter-rouge">//</code> and stop at the newline character. The newline character is assumed to be part of the comment. The comment representation is as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// this is a line comment and it includes the newline at the end of the line\n

comment = // { char_no_nl } \n
</code></pre>
</div>

<h3 id="whitespace">Whitespace</h3>

<p>Whitespace is used to separate tokens, and is defined as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>newline         = /* ASCII character nl : '\n' */ .
carriage_return = /* ASCII character cr : '\r' */ .
horizontal_tab  = /* ASCII character ht : '\t' */ .
vertical_tab    = /* ASCII character vt : '\v' */ .
form_feed       = /* ASCII character np : '\f' */ .
space           = /* ASCII character sp : ' ' */ .
whitespace      = { newline | carriage_return | horizontal_tab | vertical_tab | form_feed | space }+ .
</code></pre>
</div>

<p>The following are special characters that are not part of white space:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>bell         = /* ASCII character bel : '\a' */ .
backspace    = /* ASCII character bs : '\b' */ .
</code></pre>
</div>

<h3 id="tokens">Tokens</h3>

<p>Tokens are the vocabulary of the Decaf language. There are four classes: identifiers, keywords, operators and literals. White space is ignored except as it separates tokens that would otherwise combine into a single token. For example, <code class="highlighter-rouge">int3</code> is a single token but <code class="highlighter-rouge">int 3</code> is two tokens, a keyword <code class="highlighter-rouge">int</code> and integer <code class="highlighter-rouge">3</code>; and <code class="highlighter-rouge">int(3)</code> is a sequence of four tokens: <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">(</code>, <code class="highlighter-rouge">3</code> and <code class="highlighter-rouge">)</code>.</p>

<p>While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.</p>

<h3 id="semicolons">Semicolons</h3>

<p>The Decaf language uses semicolons <code class="highlighter-rouge">;</code> as a terminator in a number of productions.</p>

<h3 id="identifiers">Identifiers</h3>

<p>Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>identifier = letter { letter | digit } .
</code></pre>
</div>

<p>For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a
x9
_x9
ThisVariableIsInCamelCase
</code></pre>
</div>

<p>Type and constant identifiers are predeclared.</p>

<h3 id="keywords">Keywords</h3>

<p>The following keywords are reserved and may not be used as identifiers.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>bool    break   continue  else   extern  false   
for     func    if        int    null    package 
return  string  true      var    void    while  
</code></pre>
</div>

<h3 id="operators-and-delimiters">Operators and Delimiters</h3>

<p>The following character sequences represent operators (see Operators section below) and delimiters.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w">  </span><span class="p">}</span><span class="w">   </span><span class="p">[</span><span class="w">   </span><span class="p">]</span><span class="w">   </span><span class="err">,</span><span class="w">   </span><span class="err">;</span><span class="w">   </span><span class="err">(</span><span class="w">   </span><span class="err">)</span><span class="w">  </span><span class="err">=</span><span class="w">  
</span><span class="err">-</span><span class="w">  </span><span class="err">!</span><span class="w">   </span><span class="err">+</span><span class="w">   </span><span class="err">*</span><span class="w">   </span><span class="err">/</span><span class="w">   </span><span class="err">&lt;&lt;</span><span class="w">  </span><span class="err">&lt;&lt;</span><span class="w">  </span><span class="err">&lt;</span><span class="w">  </span><span class="err">&gt;</span><span class="w">  
</span><span class="err">%</span><span class="w">  </span><span class="err">&lt;=</span><span class="w">  </span><span class="err">&gt;=</span><span class="w">  </span><span class="err">==</span><span class="w">  </span><span class="err">!=</span><span class="w">  </span><span class="err">&amp;&amp;</span><span class="w">  </span><span class="err">||</span><span class="w">  </span><span class="err">.</span><span class="w">
</span></code></pre>
</div>

<h3 id="integer-literals">Integer literals</h3>

<p>An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0x or 0X for hexadecimal. In hexadecimal literals, letters a-f and A-F represent values 10 through 15.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int_lit     = decimal_lit | hex_lit .
decimal_lit = { decimal_digit }+ .
hex_lit     = "0" ( "x" | "X" ) { hex_digit }+ .
</code></pre>
</div>

<p>For example, the following are integer literals:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>42
0xBadFace
170141183460469231731687303715884105727
</code></pre>
</div>

<p>For integer literals, the semantics of range checking occurs later, so that a long sequence of digits such as the last example above which is clearly out of range is still scanned as a single token. The semantic analyzer will come in later and reject this lexeme value as a valid integer constant.</p>

<h3 id="character-literals">Character literals</h3>

<p>A character literal represents a character constant (see Constants section), which is an integer value that identifies an ASCII eqivalent. A character literal is expressed as one or more characters enclosed in single quotes. Within the quotes, any character may appear except single quote and newline. A single quoted character represents the ASCII value of the character itself, while multi-character sequences beginning with a backslash encode special ASCII values as escaped characters.</p>

<p>The simplest form represents the single character within the quotes which is equal to the integer ASCII value. For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>'a' // equal to ASCII value 97 stored as an integer type
</code></pre>
</div>

<p>After a backslash, certain single-character escapes represent special values:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>\a   ASCII 7:   alert or bell
\b   ASCII 8:   backspace
\t   ASCII 9:   horizontal tab
\n   ASCII 10:  line feed or newline
\v   ASCII 11:  vertical tab
\f   ASCII 12:  form feed
\r   ASCII 13:  carriage return
\\   ASCII 92:  backslash
\'   single quote
\"   double quote
</code></pre>
</div>

<p>The following is a list of escaped character codes that refer to the equivalent ASCII codes above.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>char_lit     = "'" ( char | escaped_char ) "'" .
escaped_char = "\" ( "n" | "r" | "t" | "v" | "f" | "a" | "b" | `\` | "'" | `"` ) .
</code></pre>
</div>

<p>The following are some legal and illegal examples of character literals:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>'a'
'\t'
'"'
'\"'
'aa'         // illegal: too many characters
''           // illegal: no characters
'\'          // illegal: invalid closing delimiter
</code></pre>
</div>

<p>Unterminated character literals must be reported as errors.</p>

<h3 id="string-literals">String literals</h3>

<p>A string literal represents a string constant obtained from concatenating a sequence of characters (also see the Constants section below).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>string_lit = `"` { char | escaped_char } `"` .
</code></pre>
</div>

<p>A string literal must start and end on a single line, it cannot be split over multiple lines. It can include escape sequences like \n and this is distinct from a newline character inside the string constant.</p>

<p>For example, the following is legal:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>"\n" 
</code></pre>
</div>

<p>But the following is not legal:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>"
"
</code></pre>
</div>

<p>Escaped characters have to used correctly. The following string has an invalid escaped character:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>"\"
</code></pre>
</div>

<p>You can have an single quote or escaped single quote in a string. So both of the following are valid.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>"'"
"\'"
</code></pre>
</div>

<p>Empty strings are allowed.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>""
</code></pre>
</div>

<p>Unterminated string literals must be reported as errors.</p>

<h3 id="type-literals">Type literals</h3>

<p>The following are the keywords used to specify Decaf types.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int bool void string
</code></pre>
</div>

<h3 id="boolean-constant-literals">Boolean constant literals</h3>

<p>The following keywords are used as constants for boolean types.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>true false
</code></pre>
</div>

<h3 id="list-of-tokens">List of Tokens</h3>

<p>The following is an alphabetically sorted list of tokens for Decaf with the token names used in the homework.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>T_AND            &amp;&amp;
T_ASSIGN         =
T_BOOLTYPE       bool
T_BREAK          break
T_CHARCONSTANT   char_lit (see section on Character literals)
T_COMMA          ,
T_COMMENT        comment
T_CONTINUE       continue
T_DIV            /
T_DOT            .
T_ELSE           else
T_EQ             ==
T_EXTERN         extern
T_FALSE          false
T_FOR            for
T_FUNC           func
T_GEQ            &gt;=
T_GT             &gt;
T_ID             identifier (see section on Identifiers)
T_IF             if
T_INTCONSTANT    int_lit (see section on Integer literals)
T_INTTYPE        int
T_LCB            {
T_LEFTSHIFT      &lt;&lt;
T_LEQ            &lt;=
T_LPAREN         (
T_LSB            [
T_LT             &lt;
T_MINUS          -
T_MOD            %
T_MULT           *
T_NEQ            !=
T_NOT            !
T_NULL           null
T_OR             ||
T_PACKAGE        package
T_PLUS           +
T_RCB            }
T_RETURN         return
T_RIGHTSHIFT     &gt;&gt;
T_RPAREN         )
T_RSB            ]
T_SEMICOLON      ;
T_STRINGCONSTANT string_lit (see section on String literals)
T_STRINGTYPE     string
T_TRUE           true
T_VAR            var
T_VOID           void
T_WHILE          while
T_WHITESPACE     whitespace (see section on Whitespace)
</code></pre>
</div>

<h2 id="types">Types</h2>

<p>Decaf has four types: void, booleans, integers and strings. String types, however, can only be used with extern functions. Void types are for return types of functions only (called MethodType below) and not used in variable declarations.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ExternType = ( string | Type ) .
Type = ( int | bool ) .
MethodType = ( void | Type ) .
</code></pre>
</div>

<p>Decaf also has a limited <em>array type</em> for arrays of integers and booleans.</p>

<h3 id="boolean-types">Boolean types</h3>

<p>A boolean type represents the set of Boolean truth values denoted by the predeclared constants <code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code>. The predeclared boolean type is <code class="highlighter-rouge">bool</code>. This is represented as the LLVM type <code class="highlighter-rouge">Int1</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>BoolConstant = ( true | false ) .
</code></pre>
</div>

<h3 id="integer-types">Integer types</h3>

<p>A integer type refers to the set of all signed 32 bit integers (-2147483648 to 2147483647) corresponding to the LLVM type <code class="highlighter-rouge">Int32</code>. The predeclared integer type is <code class="highlighter-rouge">int</code>.</p>

<h3 id="string-types">String types</h3>

<p>A string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. Strings are immutable: once created, it is impossible to change the contents of a string. The LLVM type that corresponds to a Decaf string type is <code class="highlighter-rouge">Int8Ptr</code>. The predeclared string type is <code class="highlighter-rouge">string</code>.</p>

<h3 id="array-types">Array types</h3>

<p>Decaf has integer and boolean arrays. However, arrays are declared only in the global (package declaration) scope as part of the field declarations (see FieldDecl).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ArrayType = "[" int_lit "]" Type .
</code></pre>
</div>

<p>All arrays are one-dimensional and have a size that is fixed at compile-time. Arrays are indexed from 0 to n − 1, where n &gt; 0 is the size of the array. The usual bracket notation is used to index arrays. Since arrays have a compile-time fixed size and cannot be declared as method parameters (or local variables), there is no facility to query the length of an array variable in Decaf. Arrays must be initialized to all zeroes at declaration time.</p>

<h2 id="constants">Constants</h2>

<p>Decaf has <em>boolean constants</em>, <em>integer constants</em>, and <em>string constants</em>. Integer constants can be created using character literals and integer literals. <code class="highlighter-rouge">BoolConstant</code> is defined (in the Types section) as either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Constant = ( int_lit | char_lit | BoolConstant ) .
</code></pre>
</div>

<p>String constants can only be used with extern functions. See the Types section for more details.</p>

<h2 id="decaf-program-structure">Decaf program structure</h2>

<h3 id="program">Program</h3>

<p>A Decaf program starts with optional external function declarations followed by the package definition (a Decaf package is like a module or namespace). A package has optional global variables (called field variables) followed by method (function) definitions.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Program = Externs package identifier "{" FieldDecls MethodDecls "}" .
</code></pre>
</div>

<h3 id="external-functions">External Functions</h3>

<p>A Decaf program can access external function that are linked, such as the Decaf standard library functions which are implemented in C, and accessed from within the Decaf program as external functions. For now, only external functions are allowed. External data cannot be declared.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Externs    = { ExternDefn } .
ExternDefn = extern func identifier "(" [ { ExternType }+, ] ")" MethodType ";" .
</code></pre>
</div>

<h3 id="global-variables">Global variables</h3>

<p>Decaf has global variables with scope limited to their package that appear before any method declarations. Global variables in Decaf are called <em>field declarations</em>. They can be simple declarations without initialization (assumed to be zero initialized by the compiler) or non-array variables can be declared with an assignment to a constant (see Constants section). Variables are always defined using the <code class="highlighter-rouge">var</code> reserved word.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>FieldDecls = { FieldDecl } .
FieldDecl  = var { identifier }+, Type ";" .
FieldDecl  = var { identifier }+, ArrayType ";" .
FieldDecl  = var identifier Type "=" Constant ";" .
</code></pre>
</div>

<p>The assignment to an identifier has to be a constant:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>package foo { var a int; var b int = a; } // Invalid!
</code></pre>
</div>

<p>The following is an example of an array field declaration. Notice the array type has the length before the type of the elements of the array.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>package foo { var list [100]int; } // Array declaration
</code></pre>
</div>

<h3 id="method-declarations">Method declarations</h3>

<p>Functions or methods in Decaf start with the reserved word <code class="highlighter-rouge">func</code>, then the name of the method and in parentheses is the argument list followed by the return type of the method.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>MethodDecls = { MethodDecl } .
MethodDecl  = func identifier "(" [ { identifier Type }+, ] ")" MethodType Block .
</code></pre>
</div>

<p>The program must contain a declaration for a method called <code class="highlighter-rouge">main</code> that has no parameters. The return type of the method <code class="highlighter-rouge">main</code> has to be type <code class="highlighter-rouge">int</code>, however the compiler does not enforce a return statement within the <code class="highlighter-rouge">main</code> definition (just like ANSI C). Execution of a Decaf program starts at this method <code class="highlighter-rouge">main</code>. Methods defined as part of a package can have zero or more parameters and must have a return type of type <code class="highlighter-rouge">MethodType</code> explicitly defined.</p>

<h3 id="blocks">Blocks</h3>

<p>Decaf blocks have a section for local variable definitions first followed by statements.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Block = "{" VarDecls Statements "}" .
</code></pre>
</div>

<h3 id="variable-declarations">Variable Declarations</h3>

<p>Local variables are declared using the reserved word <code class="highlighter-rouge">var</code> followed by a comma separated list of variables for each type and followed by the type of the variable(s). They cannot be assigned a value when they are defined.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>VarDecls = { VarDecl } .
VarDecl  = var { identifier }+, Type ";" .
</code></pre>
</div>

<p>There is no assignment allowed for local variables:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func foo() int { var a int = 10; } // Invalid!
</code></pre>
</div>

<h3 id="statements">Statements</h3>

<p>Statements in Decaf consist of variable assignment, method calls, syntax for various kinds of control flow, special statements for breaking out of or continuing to the top of the block.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Statements = { Statement } .
</code></pre>
</div>

<h4 id="blocks-statement">Blocks statement</h4>

<p>Statements can also be Blocks (see section on Blocks).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement = Block .
</code></pre>
</div>

<h4 id="assign-statement">Assign statement</h4>

<p>Assignment to an <code class="highlighter-rouge">Lvalue</code> is a statement in <code class="highlighter-rouge">Decaf</code>. The location for the <code class="highlighter-rouge">Lvalue</code> can be either a scalar variable or an array location.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement = Assign ";" .
Assign    = Lvalue "=" Expr .
Lvalue    = identifier | identifier "[" Expr "]" .
</code></pre>
</div>

<h4 id="method-calls">Method calls</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement  = MethodCall ";" .
MethodCall = identifier "(" [ { MethodArg }+, ] ")" .
MethodArg  = Expr | string_lit .
</code></pre>
</div>

<p>External functions are declared using the extern keyword. These functions are provided at using a separate library which is linked with your Decaf program at runtime. Some minimal type checking is done using the declaration. The most useful library functions that you will use are the <code class="highlighter-rouge">print_string</code>, <code class="highlighter-rouge">print_int</code> and <code class="highlighter-rouge">read_int</code> functions.</p>

<p>The return value can be a type that can be assigned to an <code class="highlighter-rouge">Lvalue</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>z = read_int(); 
</code></pre>
</div>

<p>In this case, the integer variable <code class="highlighter-rouge">z</code> receives the result of calling the <code class="highlighter-rouge">read_int</code> library function. The return value can also be declared to be <code class="highlighter-rouge">void</code> in which case assigning the output of a library function to an <code class="highlighter-rouge">Lvalue</code> will result in a semantic error.</p>

<h4 id="if-statement">If statement</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement = if "(" Expr ")" Block [ else Block ] .
</code></pre>
</div>

<h4 id="while-statement">While statement</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement =  while "(" Expr ")" Block .
</code></pre>
</div>

<h4 id="for-statement">For statement</h4>

<p>The <code class="highlighter-rouge">for</code> loop in Decaf has the usual structure <code class="highlighter-rouge">for ( init ; check ; post )</code> followed by the <code class="highlighter-rouge">Block</code> of the for loop.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement = for "(" { Assign }+, ";" Expr ";" { Assign }+, ")" Block .
</code></pre>
</div>

<p>The init, check and post parts of the <code class="highlighter-rouge">for</code> loop cannot be empty:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for(; a &lt; b; ) // Invalid!
</code></pre>
</div>

<h4 id="return-statement">Return statement</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement = return [ "(" [ Expr ] ")" ] ";" .
</code></pre>
</div>

<p>The following are all valid return statements:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>return(3);
return(bool);
return();
return;
</code></pre>
</div>

<h4 id="break-statement">Break statement</h4>

<p>A <code class="highlighter-rouge">break</code> statement terminates execution of the innermost <code class="highlighter-rouge">for</code> or <code class="highlighter-rouge">while</code> loop (branches to end of loop).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement = break ";" .
</code></pre>
</div>

<h4 id="continue-statement">Continue statement</h4>

<p>A <code class="highlighter-rouge">continue</code> statement begins the next iteration of the innermost <code class="highlighter-rouge">for</code> or <code class="highlighter-rouge">while</code> loop at its post statement (see For statement).</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Statement = continue ";" .
</code></pre>
</div>

<h2 id="expressions">Expressions</h2>

<h3 id="operands">Operands</h3>

<p>Operands are the elementary values in an expression.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Expr = identifier .
Expr = MethodCall .
Expr = Constant .
</code></pre>
</div>

<h3 id="unary-operators">Unary Operators</h3>

<p>There are only two unary operators in Decaf. One for logical negation and the other for unary minus of arithmetic expressions. The result of <code class="highlighter-rouge">UnaryNot</code> is of type <code class="highlighter-rouge">bool</code> and the result of <code class="highlighter-rouge">UnaryMinus</code> is of type <code class="highlighter-rouge">int</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>UnaryOperator = ( UnaryNot | UnaryMinus ) .
UnaryNot = "!" .
UnaryMinus = "-" .
</code></pre>
</div>

<h3 id="binary-operators">Binary Operators</h3>

<p>Binary operators are split into boolean binary operators and arithmetic binary operators. The result of using a boolean operator is the type <code class="highlighter-rouge">bool</code> and the result of using an arithmetic operator is the type <code class="highlighter-rouge">int</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>BinaryOperator = ( ArithmeticOperator | BooleanOperator ) .
ArithmeticOperator = ( "+" | "-" | "*" | "/" | "&lt;&lt;" | "&gt;&gt;" | "%" ) .
BooleanOperator = ( "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "&amp;&amp;" | "||" ) .
</code></pre>
</div>

<p>The boolean connectives <code class="highlighter-rouge">&amp;&amp;</code> and <code class="highlighter-rouge">||</code> are interpreted using <a href="http://en.wikipedia.org/wiki/Short-circuit_evaluation">short circuit evaluation</a>. This means: the second operand is not evaluated if the result of the first operand determines the value of the whole expression. For example, if the result is <code class="highlighter-rouge">false</code> for <code class="highlighter-rouge">&amp;&amp;</code> or <code class="highlighter-rouge">true</code> for <code class="highlighter-rouge">||</code>.</p>

<p>Binary <code class="highlighter-rouge">%</code> computes the modulus of two numbers. Given two operands of type <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>: If <code class="highlighter-rouge">b</code> is positive, then <code class="highlighter-rouge">a % b</code> is a minus the largest multiple of <code class="highlighter-rouge">b</code> that is not greater than <code class="highlighter-rouge">a</code>. If <code class="highlighter-rouge">b</code> is negative, then <code class="highlighter-rouge">a % b</code> is <code class="highlighter-rouge">a</code> minus the smallest multiple of <code class="highlighter-rouge">b</code> that is not less than <code class="highlighter-rouge">a</code> (in this case the result will be less than or equal to zero).</p>

<h3 id="operators-and-precedence">Operators and Precedence</h3>

<p>Unary operators have the highest precedence. For the other binary operators the precedence is defined as follows. All operators at the same precedence level get equal precedence. All operators with equal precedence associate left. The <code class="highlighter-rouge">UnaryMinus</code> operator associates to the right.</p>

<table>
  <thead>
    <tr>
      <th>Precedence</th>
      <th>Operator</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>7</td>
      <td><code class="highlighter-rouge">UnaryMinus</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td><code class="highlighter-rouge">UnaryNot</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td><code class="highlighter-rouge">* / % &lt;&lt; &gt;&gt;</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="highlighter-rouge">+ -</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="highlighter-rouge">== != &lt; &lt;= &gt; &gt;=</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code class="highlighter-rouge">&amp;&amp;</code></td>
    </tr>
    <tr>
      <td>1</td>
      <td><code class="highlighter-rouge">||</code></td>
    </tr>
  </tbody>
</table>

<h3 id="primary-expressions">Primary expressions</h3>

<p>Primary expressions build larger expressions from operands, operators and parentheses. The parentheses are used to group expressions to obtain different orders of evaluation. Parentheses can be omitted if the desired evaluation is consistent with the precedence rules (see the Operators and Precedence section). The type of the <code class="highlighter-rouge">Expr</code> on the left hand side is determined by the <code class="highlighter-rouge">Expr</code> on the right hand side and the operator used.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Expr = Expr BinaryOperator Expr .
Expr = UnaryOperator Expr .
Expr = "(" Expr ")" .
</code></pre>
</div>

<h3 id="index-expression">Index expression</h3>

<p>In this expression, the <code class="highlighter-rouge">identifier</code> must be an Array Type (see section on Array Types). The <code class="highlighter-rouge">Expr</code> is evaluated to give an array index and the result of the evaluation must be of type <code class="highlighter-rouge">int</code>. The integer value is then used to find the element of the array which is of type <code class="highlighter-rouge">int</code> or <code class="highlighter-rouge">bool</code> depending on the Array Type.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Expr = identifier "[" Expr "]" .
</code></pre>
</div>

<h3 id="decaf-grammar">Decaf grammar</h3>

<p>The entire set of rules that describe the <code class="highlighter-rouge">Decaf</code> grammar specification
is collected in one place below. For explanation of each of the
rules read the descriptions provided in the above sections.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Program = Externs package identifier "{" FieldDecls MethodDecls "}" .
Externs    = { ExternDefn } .
ExternDefn = extern func identifier "(" [ { ExternType }+, ] ")" MethodType ";" .
FieldDecls = { FieldDecl } .
FieldDecl  = var { identifier }+, Type ";" .
FieldDecl  = var { identifier }+, ArrayType ";" .
FieldDecl  = var identifier Type "=" Constant ";" .
MethodDecls = { MethodDecl } .
MethodDecl  = func identifier "(" [ { identifier Type }+, ] ")" MethodType Block .
Block = "{" VarDecls Statements "}" .
VarDecls = { VarDecl } .
VarDecl  = var { identifier }+, Type ";" .
Statements = { Statement } .
Statement = Block .
Statement = Assign ";" .
Assign    = Lvalue "=" Expr .
Lvalue    = identifier | identifier "[" Expr "]" .
Statement  = MethodCall ";" .
MethodCall = identifier "(" [ { MethodArg }+, ] ")" .
MethodArg  = Expr | string_lit .
Statement = if "(" Expr ")" Block [ else Block ] .
Statement =  while "(" Expr ")" Block .
Statement = for "(" { Assign }+, ";" Expr ";" { Assign }+, ")" Block .
Statement = return [ "(" [ Expr ] ")" ] ";" .
Statement = break ";" .
Statement = continue ";" .
Expr = identifier .
Expr = MethodCall .
Expr = Constant .
UnaryOperator = ( UnaryNot | UnaryMinus ) .
UnaryNot = "!" .
UnaryMinus = "-" .
BinaryOperator = ( ArithmeticOperator | BooleanOperator ) .
ArithmeticOperator = ( "+" | "-" | "*" | "/" | "&lt;&lt;" | "&gt;&gt;" | "%" ) .
BooleanOperator = ( "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "&amp;&amp;" | "||" ) .
Expr = Expr BinaryOperator Expr .
Expr = UnaryOperator Expr .
Expr = "(" Expr ")" .
Expr = identifier "[" Expr "]" .
ExternType = ( string | Type ) .
Type = ( int | bool ) .
MethodType = ( void | Type ) .
BoolConstant = ( true | false ) .
ArrayType = "[" int_lit "]" Type .
Constant = ( int_lit | char_lit | BoolConstant ) .
</code></pre>
</div>

<h2 id="decaf-semantics">Decaf Semantics</h2>

<h3 id="program-structure">Program Structure</h3>

<ul>
  <li>A method called <code class="highlighter-rouge">main</code> has to exist in the Decaf program.</li>
</ul>

<h3 id="type-checking">Type Checking</h3>

<p>Make sure the following type checks are implemented in the compiler.</p>

<ul>
  <li>Binary <code class="highlighter-rouge">+</code> <code class="highlighter-rouge">-</code> <code class="highlighter-rouge">*</code> <code class="highlighter-rouge">/</code> <code class="highlighter-rouge">%</code> <code class="highlighter-rouge">&gt;&gt;</code> <code class="highlighter-rouge">&lt;&lt;</code> <code class="highlighter-rouge">&lt;</code> <code class="highlighter-rouge">&gt;</code> <code class="highlighter-rouge">&lt;=</code> <code class="highlighter-rouge">&gt;=</code> and unary <code class="highlighter-rouge">-</code> only work on integer expressions.</li>
  <li>Binary <code class="highlighter-rouge">&amp;&amp;</code> <code class="highlighter-rouge">||</code> and unary <code class="highlighter-rouge">!</code> only work on boolean expressions.</li>
  <li>Binary <code class="highlighter-rouge">==</code> <code class="highlighter-rouge">!=</code> work on any type, but both operands have to have the same type.</li>
  <li>Assignment to a function parameter is valid and should change the value as for a local variable</li>
  <li>The <code class="highlighter-rouge">&amp;&amp;</code> and <code class="highlighter-rouge">||</code> operators are short-circuiting (this is already specified in the spec)</li>
  <li>If you have multiple return statements in one block then only the first is used, but the others should still be type checked.</li>
  <li>Indexing a scalar is a semantic error. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">x[0]</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">1;</span><span class="w"> </span><span class="p">}</span></code> is a semantic error, and <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x,y</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">y</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">x[0];</span><span class="w"> </span><span class="p">}</span></code> is a semantic error, and the same if <code class="highlighter-rouge">x</code> is a field variable.</li>
  <li>Indexing with a bool is a semantic error. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">xs[10]</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">func</span><span class="w"> </span><span class="err">main()</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">xs[true];</span><span class="w"> </span><span class="p">}</span></code> is a semantic error.</li>
  <li>Using a non-bool expression for a loop condition is a semantic error. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">while</span><span class="w"> </span><span class="err">(1)</span><span class="w"> </span><span class="err">{</span><span class="p">}</span><span class="w"> </span><span class="err">}</span></code> and <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">(x</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">0;</span><span class="w"> </span><span class="err">1;</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="err">1)</span><span class="w"> </span><span class="err">{</span><span class="p">}</span><span class="w"> </span><span class="err">}</span></code> are semantic errors.</li>
  <li>Using a non-bool expression in an if statement condition is a semantic error. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">if</span><span class="w"> </span><span class="err">(0)</span><span class="w"> </span><span class="err">{</span><span class="p">}</span><span class="w"> </span><span class="err">}</span></code> is a semantic error.</li>
  <li>A return statement with an expression is not allowed in function with void return type. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">func</span><span class="w"> </span><span class="err">foo()</span><span class="w"> </span><span class="err">void</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">(1);</span><span class="w"> </span><span class="p">}</span></code> and <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">func</span><span class="w"> </span><span class="err">bar()</span><span class="w"> </span><span class="err">void</span><span class="w"> </span><span class="err">{</span><span class="p">}</span><span class="w"> </span><span class="err">func</span><span class="w"> </span><span class="err">foo()</span><span class="w"> </span><span class="err">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">(bar());</span><span class="w"> </span><span class="p">}</span></code> are both semantic errors.</li>
  <li>A return statement with no expression in a non-void function produces an undefined return value. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">func</span><span class="w"> </span><span class="err">foo()</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="err">return;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="err">func</span><span class="w"> </span><span class="err">main()</span><span class="w"> </span><span class="err">int</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">foo();</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="err">}</span></code> is a not a semantic error, but the value of <code class="highlighter-rouge">x</code> may be anything (typically zero due to zero initialization).</li>
  <li>Cannot use a void function in an expression. <code class="highlighter-rouge">func foo() void {} func main() int { if (foo()) {} }</code> is invalid.</li>
  <li>Cannot call a method with the wrong number of arguments.</li>
  <li>Find all cases where there is a type mismatch between the definition of the type of a variable and a value assigned to that variable. e.g. <code class="highlighter-rouge">bool x; x = 10;</code> is an example of a type mismatch.</li>
  <li>Find all cases where an expression is well-formed, where binary and unary operators are distinguished from relational and equality operators. e.g. <code class="highlighter-rouge">true + false</code> is an example of a mismatch but <code class="highlighter-rouge">true != true</code> is not a mismatch.</li>
  <li>Check that all variables are defined in the proper scope before they are used as an lvalue or rvalue in a Decaf program.</li>
  <li>Check that the return statement in a method matches the return type in the method definition. e.g. <code class="highlighter-rouge">func foo() bool { return(10); }</code> is an example of a mismatch.</li>
</ul>

<h3 id="scoping-rules">Scoping Rules</h3>

<p>This section clarifies the behaviour with scoping.</p>

<ul>
  <li>Having two fields with the same name is a semantic error.</li>
  <li>Having two methods with the same name is a semantic error.</li>
  <li>Having a field and a method with the same name is a semantic error.</li>
  <li>externs count as methods for scoping.</li>
  <li>Having two local variables with the same name declared at the same block is a semantic error. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="p">}</span></code> is an error, but <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="err">{</span><span class="w"> </span><span class="err">var</span><span class="w"> </span><span class="err">x</span><span class="w"> </span><span class="err">int;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="err">}</span></code> is ok.</li>
  <li>Having a local variable in the outer block of a method that has a parameter with the same name is a semantic error. <code class="highlighter-rouge">func foo(x int) void { var x int; }</code> is an error, but <code class="highlighter-rouge">func foo(x int) void { { var x int; } }</code> is ok.</li>
  <li>A function can be referred to anywhere in the program, including before its definition. <code class="highlighter-rouge">package C { func foo() void { bar() }; func bar() void {}; /* ... */ }</code> is ok.</li>
  <li>Functions, fields, arguments, and local variables all share the same namespace (symbol table) and can shadow each other except for the above rules. e.g. in <code class="highlighter-rouge">package C { func foo() void {}; func bar() void { var foo int; foo(); } /* ... */ }</code> the <code class="highlighter-rouge">foo</code> in <code class="highlighter-rouge">foo();</code> refers to the local int variable, not the function resulting in an error.</li>
  <li><code class="highlighter-rouge">break</code> and <code class="highlighter-rouge">continue</code> only apply to the innermost containing loop. Using <code class="highlighter-rouge">break</code> or <code class="highlighter-rouge">continue</code> outside of a loop results in a semantic error.</li>
</ul>

<h3 id="statements-1">Statements</h3>

<p>These are semantic errors that can occur when using statements in Decaf.</p>

<ul>
  <li>There are no restrictions on the type of <code class="highlighter-rouge">main</code> but a return statement inside main must match the return type of <code class="highlighter-rouge">main</code>. Always emitting <code class="highlighter-rouge">int</code> as the return type for <code class="highlighter-rouge">main</code> is safe.</li>
  <li>Assigning a scalar to an array is considered a type mismatch.</li>
  <li>The following produce undefined behaviour, but must not produce compile time semantic errors:
    <ul>
      <li>Using the value of any uninitialized scalar variable or array element</li>
      <li>A function with no return statement is equivalent to ending the function with a return statement that has no expression: <code class="highlighter-rouge">return;</code></li>
      <li>Assigning to an array cell at an invalid index</li>
    </ul>
  </li>
  <li>Any bool argument to a integer parameter must be converted while keeping its value, not just for <code class="highlighter-rouge">print_int</code>.</li>
  <li>Passing a argument to a function parameter with a different type is a semantic error except for the special case of passing a <code class="highlighter-rouge">bool</code> as an <code class="highlighter-rouge">int</code>.</li>
  <li>Declaring an array of size less than or equal to zero is a semantic error.</li>
  <li>Assignment to a function parameter is valid and should change the value as for a local variable.</li>
</ul>


        </div>
      </div>

      <footer class="text-center text-muted">
        <hr>
        Last updated August 15, 2016.<br>
        Forked from the JHU MT class code on <a href="https://github.com/mt-class/jhu">github <i class="fa fa-github-alt"></i></a> by <a href="https://github.com/mjpost">Matt Post</a> and <a href="https://github.com/alopez">Adam Lopez</a>.<br>
        <br><br>
      </footer>
    </div>

    <!-- Page content of course! -->
    <!-- JS and analytics only. -->
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="./SFUCompilersclass_DecafSpecification_files/bootstrap.js"></script>
    <script type="text/javascript">
      $(document).ready(function(){
        $("#homework").addClass("active");
      });
    </script>
  

</body></html>
